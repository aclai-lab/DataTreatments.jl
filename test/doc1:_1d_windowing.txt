using DataTreatments
using SoleXplorer

A = rand(1150, 1150);
B = rand(2500);

points = length(B)
SX_w = MovingWindow(window_size=10, window_step=5)
SX_movingwindow = SX_w(points)
DT_w = movingwindow(winsize=10, winstep=5)
DT_movingwindow = @evalwindow points DT_w
SX_movingwindow == DT_movingwindow

@btime begin
    points = length(B)
    SX_w = MovingWindow(window_size=10, window_step=5)
    SX_movingwindow = SX_w(points)
end
# 1.344 μs (5 allocations: 7.91 KiB)

@btime begin
    DT_w = movingwindow(winsize=10, winstep=5)
    DT_movingwindow = @evalwindow B DT_w
end
# 1.273 μs (7 allocations: 11.91 KiB)

SX_w = WholeWindow()
SX_wholewindow = SX_w(points)
DT_w = wholewindow()
DT_wholewindow = @evalwindow points DT_w
SX_wholewindow == DT_wholewindow

@btime begin
    points = length(B)
    SX_w = WholeWindow()
    SX_wholewindow = SX_w(points)
end
# 849.787 ns (15 allocations: 448 bytes)

@btime begin
    DT_w = wholewindow()
    DT_wholewindow = @evalwindow B DT_w
end
# 58.831 ns (7 allocations: 192 bytes)

SX_w = SplitWindow(nwindows=11)
SX_splitwindow = SX_w(points)
DT_w = splitwindow(nwindows=11)
DT_splitwindow = @evalwindow points DT_w
length(DT_splitwindow) == 11

@btime begin
    points = length(B)
    SX_w = SplitWindow(nwindows=11)
    SX_splitwindow = SX_w(points)
end
# 4.385 μs (102 allocations: 2.89 KiB)

@btime begin
    DT_w = splitwindow(nwindows=11)
    DT_splitwindow = @evalwindow B DT_w
end
# 169.756 ns (6 allocations: 544 bytes)

SX_w = AdaptiveWindow(nwindows=11, relative_overlap=0.1)
SX_adaptivewindow = SX_w(points)
DT_w = adaptivewindow(nwindows=11, overlap=0.1)
DT_adaptivewindow = @evalwindow points DT_w
length(DT_splitwindow) == 11

@btime begin
        points = length(B)
    SX_w = AdaptiveWindow(nwindows=11, relative_overlap=0.1)
    SX_adaptivewindow = SX_w(points)
end
# 4.342 μs (102 allocations: 2.89 KiB)

@btime begin
    DT_w = adaptivewindow(nwindows=11, overlap=0.1)
    DT_adaptivewindow = @evalwindow B DT_w
end
# 167.503 ns (6 allocations: 544 bytes)

#####################################################################
@btime begin
    Xresult1 = similar(Xm)
    for i in eachindex(Xm)
        @inbounds Xresult1[i] = _reducesize(Xm[i], intervals)
    end
end;
# 2.138 s (498981 allocations: 25.16 MiB)

@btime begin
    Xresult1 = similar(Xm)
    Threads.@threads for i in eachindex(Xm)
        @inbounds Xresult1[i] = _reducesize(Xm[i], intervals)
    end
end;
# 325.657 ms (299581 allocations: 20.60 MiB)

@btime aggregate(Xm, intervals)

# ---------------------------------------------------------------------------- #
#                                 constructors                                 #
# ---------------------------------------------------------------------------- #
# using DataFrames
using DataTreatments
reducefunc = mean
features = (maximum, minimum, mean)

X = rand(1000)
wfunc = splitwindow(nwindows=10)
intervals = @evalwindow X wfunc

X = rand(200, 120)
intervals = @evalwindow X splitwindow(nwindows=5) splitwindow(nwindows=3)

Xm = fill(X, 100, 1000)
# Xd = DataFrame(Xm, :auto)

#####################################################################
@btime reducesize(Xm, intervals)

@btime begin
    nwindows = prod(length.(intervals))
    nfeats = nwindows * length(features)
    Xresult = Array{core_eltype(Xm)}(undef, size(Xm, 1), size(Xm, 2) * nfeats)
    Threads.@threads for i in eachindex(Xm)
        idx = CartesianIndices(Xm)[i]
        row, col = idx[1], idx[2]
        @views @inbounds for j in eachindex(features)
            reduced = applyfeat(Xm[i], intervals; reducefunc=features[j])
            col_start = (col - 1) * nfeats + (j - 1) * nwindows + 1
            col_end = col_start + nwindows - 1
            @inbounds copyto!(view(Xresult, row, col_start:col_end), vec(reduced))
        end
    end
end
# 2.293 s (1698556 allocations: 79.33 MiB)
i,j = 1,1
@btime [applyfeat(elem, intervals; reducefunc=features[j]) for elem in Xm[:, i]]
# 3.954 ms (208 allocations: 20.62 KiB)
@btime [vec(applyfeat(elem, intervals; reducefunc=features[j])) for elem in Xm[:, i]]
# 3.939 ms (308 allocations: 23.75 KiB)

@btime a=[applyfeat(elem, intervals; reducefunc=features[j]) for elem in Xm[:, i]]
# 3.915 ms (208 allocations: 20.62 KiB)
@btime begin
    result = Matrix{core_eltype(Xm)}(undef, size(Xm, 1), prod(length.(intervals)))
    for (idx, elem) in enumerate(Xm[:, i])
        result[idx, :] = vec(applyfeat(elem, intervals; reducefunc=features[j]))
    end
    result
end
# 3.962 ms (709 allocations: 47.21 KiB)
@btime begin
    result = Matrix{core_eltype(Xm)}(undef, size(Xm, 1), prod(length.(intervals)))
    Threads.@threads for idx in axes(Xm, 1)
        result[idx, :] = vec(applyfeat(Xm[idx, i], intervals; reducefunc=features[j]))
    end
    result
end
# 895.589 μs (494 allocations: 40.45 KiB)
@btime begin
    result = Matrix{core_eltype(Xm)}(undef, size(Xm, 1), prod(length.(intervals)))
    Threads.@threads for idx in axes(Xm, 1)
        @inbounds @views result[idx, :] = vec(applyfeat(Xm[idx, i], intervals; reducefunc=features[j]))
    end
    result
end
# 882.436 μs (494 allocations: 40.45 KiB)
@btime begin
    nrows = size(Xm, 1)
    nthreads = Threads.nthreads()
    chunk_size = cld(nrows, nthreads)
    result = Matrix{core_eltype(Xm)}(undef, nrows, prod(length.(intervals)))
    
    Threads.@threads :static for chunk_start in 1:chunk_size:nrows
        chunk_end = min(chunk_start + chunk_size - 1, nrows)
        for idx in chunk_start:chunk_end
            @inbounds result[idx, :] = vec(applyfeat(Xm[idx, i], intervals; reducefunc=features[j]))
        end
    end
    result
end
# 884.633 μs (494 allocations: 41.65 KiB)

@btime reduce(hcat, vec.(a))'
# 1.516 μs (107 allocations: 15.90 KiB)
@btime reshape(reduce(vcat, vec.(a)), length(a), :)
# 1.645 μs (109 allocations: 16.82 KiB)
@btime mapreduce(vec, hcat, a)'
# 40.845 μs (383 allocations: 606.11 KiB)
@btime begin
    result = Matrix{Float64}(undef, 100, 15)
    for i in eachindex(a)
        result[i, :] = vec(a[i])
    end
end
# 13.505 μs (703 allocations: 32.13 KiB)

@btime begin
    nwindows = prod(length.(intervals))
    result = stack(
        vec(applyfeat(Xm[row, col], intervals; reducefunc=feat))
        for row in axes(Xm, 1)
        for col in axes(Xm, 2)
        for feat in features
    )
    reshape(result, size(Xm, 1), :)
end

@btime begin
    nwindows = prod(length.(intervals))
    vecs = [vec(applyfeat(Xm[row, col], intervals; reducefunc=feat))
            for row in axes(Xm, 1), col in axes(Xm, 2), feat in features]
    # Flatten the last two dimensions and stack
    reduce(hcat, vec(vecs))'
end
# 11.366 s (1901978 allocations: 122.10 MiB)

@btime begin
    nwindows = prod(length.(intervals))
    nfeats = nwindows * length(features)
    Xresult = Array{core_eltype(Xm)}(undef, size(Xm, 1), size(Xm, 2) * nfeats)
    Threads.@threads for i in eachindex(Xm)
        idx = CartesianIndices(Xm)[i]
        row, col = idx[1], idx[2]
        @views @inbounds for j in eachindex(features)
            reduced = applyfeat(Xm[i], intervals; reducefunc=features[j])
            col_start = (col - 1) * nfeats + (j - 1) * nwindows + 1
            col_end = col_start + nwindows - 1
            @inbounds copyto!(view(Xresult, row, col_start:col_end), vec(reduced))
        end
    end
end
# 1.693 s (4775959 allocations: 203.35 MiB)

@btime begin
    nwindows = prod(length.(intervals))
    nfeats = nwindows * length(features)
    Xresult = Array{core_eltype(Xm)}(undef, size(Xm, 1), size(Xm, 2) * nfeats)
    
    # Threads.@threads for i in eachindex(Xm)
    @inbounds Threads.@threads for colidx in axes(Xm, 2)
        for rowidx in axes(Xm,1)
        # idx = CartesianIndices(Xm)[i]
        # row, col = idx[1], idx[2]

        all_reduced = mapreduce(vcat, features) do feat
            vec(applyfeat(Xm[rowidx,colidx], intervals; reducefunc=feat))
        end
        
        col_start = (colidx - 1) * nfeats + 1
        col_end = col_start + nfeats - 1
        @inbounds copyto!(view(Xresult, rowidx, col_start:col_end), all_reduced)
        end
    end
    # Xresult
end
# 1.704 s (2595703 allocations: 211.26 MiB)

@btime begin
    nwindows = prod(length.(intervals))
    nfeats = nwindows * length(features)
    Xresult = Array{core_eltype(Xm)}(undef, size(Xm, 1), size(Xm, 2) * nfeats)
    
    @inbounds Threads.@threads for colidx in axes(Xm, 2)
        for rowidx in axes(Xm,1)
            reduced = mapreduce(vcat, features) do feat
                vec(applyfeat(Xm[rowidx,colidx], intervals; reducefunc=feat))
            end
            
            base_idx = (colidx - 1) * nfeats
            @inbounds copyto!(view(Xresult, rowidx, base_idx+1:base_idx+nfeats), vec(reduced))
        end
    end
    Xresult
end
# 1.665 s (2995703 allocations: 218.89 MiB)
